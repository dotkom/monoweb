generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["relationJoins"]
}

generator zod {
  provider = "zod-prisma-types"
  output   = "../src/schemas"

  useMultipleFiles = false
  createInputTypes = false
  addIncludeType   = false
  addSelectType    = false
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum MembershipType {
  BACHELOR_STUDENT @map("BACHELOR_STUDENT")
  MASTER_STUDENT   @map("MASTER_STUDENT")
  PHD_STUDENT      @map("PHD_STUDENT")
  KNIGHT           @map("KNIGHT")
  SOCIAL_MEMBER    @map("SOCIAL_MEMBER")
  OTHER            @map("OTHER")

  @@map("membership_type")
}

/// Taken from the Feide API. The values were found by digging around in our Auth0 user profiles.
///
/// We have an additional value `UNKNOWN` to represent users that do not have a specialization or if some new value is
/// suddenly added to the Feide API that we do not yet know about.
enum MembershipSpecialization {
  ARTIFICIAL_INTELLIGENCE @map("ARTIFICIAL_INTELLIGENCE")
  DATABASE_AND_SEARCH     @map("DATABASE_AND_SEARCH")
  INTERACTION_DESIGN      @map("INTERACTION_DESIGN")
  SOFTWARE_ENGINEERING    @map("SOFTWARE_ENGINEERING")
  UNKNOWN                 @map("UNKNOWN")

  @@map("membership_specialization")
}

model Membership {
  id             String                    @id @default(uuid())
  userId         String                    @map("user_id")
  user           User                      @relation(fields: [userId], references: [id])
  type           MembershipType
  specialization MembershipSpecialization? @default(UNKNOWN)
  start          DateTime                  @db.Timestamptz(3)
  end            DateTime                  @db.Timestamptz(3)

  @@map("membership")
}

model User {
  /// OpenID Connect Subject claim - for this reason there is no @default(uuid()) here.
  id                  String   @id
  profileSlug         String   @unique @map("username")
  name                String?
  email               String?
  imageUrl            String?  @map("image_url")
  biography           String?
  phone               String?
  gender              String?
  dietaryRestrictions String?  @map("dietary_restrictions")
  ntnuUsername        String?  @map("ntnu_username")
  flags               String[]
  /// Used for identifying the user in Google Workspace (my.name@online.ntnu.no)
  workspaceUserId     String?  @unique @map("workspace_user_id")
  createdAt           DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt           DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  privacyPermissionsId      String?                  @unique @map("privacy_permissions_id")
  privacyPermissions        PrivacyPermissions?
  notificationPermissionsId String?                  @unique @map("notification_permissions_id")
  notificationPermissions   NotificationPermissions?

  attendee          Attendee[]
  personalMark      PersonalMark[]
  groupMemberships  GroupMembership[]
  memberships       Membership[]
  givenMarks        PersonalMark[]     @relation("GivenBy")
  attendeesRefunded Attendee[]         @relation(name: "RefundedBy")
  auditLogs         AuditLog[]
  deregisterReasons DeregisterReason[]

  @@map("ow_user")
}

model Company {
  id          String   @id @default(uuid())
  name        String
  slug        String   @unique
  description String?
  phone       String?
  email       String?
  website     String
  location    String?
  imageUrl    String?  @map("image_url")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  events     EventCompany[]
  JobListing JobListing[]

  @@map("company")
}

enum GroupType {
  COMMITTEE      @map("COMMITTEE")
  NODE_COMMITTEE @map("NODE_COMMITTEE")
  ASSOCIATED     @map("ASSOCIATED")
  INTEREST_GROUP @map("INTEREST_GROUP")

  @@map("group_type")
}

enum GroupMemberVisibility {
  ALL_MEMBERS @map("ALL_MEMBERS")
  WITH_ROLES  @map("WITH_ROLES")
  LEADER      @map("LEADER")
  NONE        @map("NONE")

  @@map("group_member_visibility")
}

enum GroupRecruitmentMethod {
  NONE               @map("NONE")
  SPRING_APPLICATION @map("SPRING_APPLICATION")
  AUTUMN_APPLICATION @map("AUTUMN_APPLICATION")
  GENERAL_ASSEMBLY   @map("GENERAL_ASSEMBLY")
  NOMINATION         @map("NOMINATION")
  OTHER              @map("OTHER")
}

model Group {
  slug                String                 @id @unique
  abbreviation        String
  name                String?
  shortDescription    String?                @map("short_description")
  description         String
  imageUrl            String?                @map("image_url")
  email               String?
  contactUrl          String?                @map("contact_url")
  showLeaderAsContact Boolean                @default(false) @map("show_leader_as_contact")
  createdAt           DateTime               @default(now()) @map("created_at") @db.Timestamptz(3)
  deactivatedAt       DateTime?              @map("deactivated_at")
  workspaceGroupId    String?                @unique @map("workspace_group_id")
  memberVisibility    GroupMemberVisibility  @default(ALL_MEMBERS) @map("member_visibility")
  recruitmentMethod   GroupRecruitmentMethod @default(NONE) @map("recruitment_method")

  events      EventHostingGroup[]
  type        GroupType
  memberships GroupMembership[]
  marks       MarkGroup[]
  roles       GroupRole[]

  @@map("group")
}

model GroupMembership {
  id        String    @id @default(uuid())
  start     DateTime  @db.Timestamptz(3)
  end       DateTime? @db.Timestamptz(3)
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  groupId String @map("group_id")
  userId  String @map("user_id")
  group   Group  @relation(fields: [groupId], references: [slug], onDelete: Cascade)
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  roles GroupMembershipRole[]

  @@map("group_membership")
}

model GroupMembershipRole {
  membershipId String          @map("membership_id")
  roleId       String          @map("role_id")
  membership   GroupMembership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  role         GroupRole       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([membershipId, roleId])
  @@map("group_membership_role")
}

enum GroupRoleType {
  LEADER        @map("LEADER")
  PUNISHER      @map("PUNISHER")
  TREASURER     @map("TREASURER")
  COSMETIC      @map("COSMETIC")
  DEPUTY_LEADER @map("DEPUTY_LEADER")
  TRUSTEE       @map("TRUSTEE")
  EMAIL_ONLY    @map("EMAIL_ONLY")

  @@map("group_role_type")
}

model GroupRole {
  id   String        @id @default(uuid())
  name String
  type GroupRoleType @default(COSMETIC)

  groupId String @map("group_id")
  group   Group  @relation(fields: [groupId], references: [slug], onDelete: Cascade)

  groupMembershipRoles GroupMembershipRole[]

  @@unique([groupId, name])
  @@map("group_role")
}

enum EventStatus {
  DRAFT   @map("DRAFT")
  PUBLIC  @map("PUBLIC")
  DELETED @map("DELETED")

  @@map("event_status")
}

enum EventType {
  /// Generalforsamling
  GENERAL_ASSEMBLY @map("GENERAL_ASSEMBLY")
  /// Bedriftspresentasjon
  COMPANY          @map("COMPANY")
  /// Kurs
  ACADEMIC         @map("ACADEMIC")
  /// Sosialt
  SOCIAL           @map("SOCIAL")
  // This type is for the rare occation we have an event that is only open to committee members.
  /// Komit√©arrangement
  INTERNAL         @map("INTERNAL")
  OTHER            @map("OTHER")
  // This type is for a committe called "velkom" and are special social events for new students.
  // These have a separate type because we have historically hid these from event lists to not
  // spam students that are not new with these events. In older versions of OnlineWeb these
  // were even treated as a completely separate event entity.
  /// Velkom/Fadderukene
  WELCOME          @map("WELCOME")

  @@map("event_type")
}

model Attendance {
  id                 String   @id @default(uuid())
  registerStart      DateTime @map("register_start") @db.Timestamptz(3)
  registerEnd        DateTime @map("register_end") @db.Timestamptz(3)
  deregisterDeadline DateTime @map("deregister_deadline") @db.Timestamptz(3)
  selections         Json     @default("[]")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt          DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)
  /// The price as a whole integer in NOK (value 100 means NOK100.00)
  attendancePrice    Int?     @map("attendance_price")

  pools     AttendancePool[]
  attendees Attendee[]
  events    Event[]

  @@map("attendance")
}

model AttendancePool {
  id              String   @id @default(uuid())
  title           String
  mergeDelayHours Int?     @map("merge_delay_hours")
  yearCriteria    Json     @map("year_criteria")
  capacity        Int
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  attendanceId String     @map("attendance_id")
  taskId       String?    @map("task_id")
  attendance   Attendance @relation(fields: [attendanceId], references: [id])
  task         Task?      @relation(fields: [taskId], references: [id], onDelete: Cascade)

  attendees Attendee[]

  @@map("attendance_pool")
}

model Attendee {
  id                    String              @id @default(uuid())
  /// To preserve the user's grade at the time of registration
  userGrade             Int?                @map("user_grade")
  feedbackFormAnswer    FeedbackFormAnswer?
  /// Which options the user has selected from the Attendance selections
  selections            Json                @default("[]")
  reserved              Boolean
  earliestReservationAt DateTime            @map("earliest_reservation_at") @db.Timestamptz(3)
  attendedAt            DateTime?           @map("attended_at") @db.Timestamptz(3)
  createdAt             DateTime            @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt             DateTime            @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)
  paymentDeadline       DateTime?           @map("payment_deadline")
  paymentLink           String?             @map("payment_link")
  paymentId             String?             @map("payment_id")
  paymentReservedAt     DateTime?           @map("payment_reserved_at")
  paymentChargeDeadline DateTime?           @map("payment_charge_deadline")
  paymentChargedAt      DateTime?           @map("payment_charged_at")
  paymentRefundedAt     DateTime?           @map("payment_refunded_at")
  paymentCheckoutUrl    String?             @map("payment_checkout_url")

  attendanceId        String         @map("attendance_id")
  userId              String         @map("user_id")
  attendancePoolId    String         @map("attendance_pool_id")
  paymentRefundedById String?        @map("payment_refunded_by_id")
  attendance          Attendance     @relation(fields: [attendanceId], references: [id])
  user                User           @relation(fields: [userId], references: [id])
  attendancePool      AttendancePool @relation(fields: [attendancePoolId], references: [id])
  paymentRefundedBy   User?          @relation(fields: [paymentRefundedById], references: [id], name: "RefundedBy")

  @@unique([attendanceId, userId], name: "attendee_unique")
  @@map("attendee")
}

model Event {
  id                      String        @id @default(uuid())
  title                   String
  start                   DateTime      @db.Timestamptz(3)
  end                     DateTime      @db.Timestamptz(3)
  status                  EventStatus
  description             String
  shortDescription        String?       @map("short_description")
  imageUrl                String?       @map("image_url")
  locationTitle           String?       @map("location_title")
  locationAddress         String?       @map("location_address")
  locationLink            String?       @map("location_link")
  type                    EventType
  feedbackForm            FeedbackForm?
  markForMissedAttendance Boolean       @default(true) @map("mark_for_missed_attendance")
  createdAt               DateTime      @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt               DateTime      @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  attendanceId String?     @map("attendance_id")
  parentId     String?     @map("parent_id")
  attendance   Attendance? @relation(fields: [attendanceId], references: [id])
  parent       Event?      @relation("children", fields: [parentId], references: [id], map: "event_parent_fkey")
  children     Event[]     @relation("children")

  companies         EventCompany[]
  hostingGroups     EventHostingGroup[]
  deregisterReasons DeregisterReason[]

  /// Historical metadata -- This is the id of the event in the previous version of OnlineWeb, if it was imported from
  /// the previous version
  metadataImportId Int? @map("metadata_import_id")

  @@map("event")
}

model EventCompany {
  eventId   String  @map("event_id")
  companyId String  @map("company_id")
  event     Event   @relation(fields: [eventId], references: [id])
  company   Company @relation(fields: [companyId], references: [id])

  @@id([eventId, companyId])
  @@map("event_company")
}

enum MarkType {
  MANUAL
  LATE_ATTENDANCE
  MISSED_ATTENDANCE
  MISSING_FEEDBACK
  MISSING_PAYMENT
}

model Mark {
  id        String   @id @default(uuid())
  title     String
  details   String?
  /// Duration in days
  duration  Int
  weight    Int
  type      MarkType @default(MANUAL)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  users  PersonalMark[]
  groups MarkGroup[]

  @@map("mark")
}

model MarkGroup {
  markId  String @map("mark_id")
  groupId String @map("group_id")
  mark    Mark   @relation(fields: [markId], references: [id])
  group   Group  @relation(fields: [groupId], references: [slug])

  @@id([markId, groupId])
  @@map("mark_group")
}

model PersonalMark {
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  markId    String  @map("mark_id")
  userId    String  @map("user_id")
  givenById String? @map("given_by_id")
  mark      Mark    @relation(fields: [markId], references: [id])
  user      User    @relation(fields: [userId], references: [id])
  givenBy   User?   @relation("GivenBy", fields: [givenById], references: [id])

  @@id([markId, userId])
  @@map("personal_mark")
}

model PrivacyPermissions {
  id                String   @id @default(uuid())
  user              User     @relation(fields: [userId], references: [id])
  userId            String   @unique @map("user_id")
  // TODO: rename to ~"privateProfile" and require authentication to view profile if true
  profileVisible    Boolean  @default(true) @map("profile_visible")
  usernameVisible   Boolean  @default(true) @map("username_visible")
  emailVisible      Boolean  @default(false) @map("email_visible")
  phoneVisible      Boolean  @default(false) @map("phone_visible")
  // TODO: delete this prop -- we do not have an address field on User
  addressVisible    Boolean  @default(false) @map("address_visible")
  // TODO: default to true
  attendanceVisible Boolean  @default(false) @map("attendance_visible")
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("privacy_permissions")
}

model NotificationPermissions {
  id                          String   @id @default(uuid())
  user                        User     @relation(fields: [userId], references: [id])
  userId                      String   @unique @map("user_id")
  applications                Boolean  @default(true)
  newArticles                 Boolean  @default(true) @map("new_articles")
  standardNotifications       Boolean  @default(true) @map("standard_notifications")
  groupMessages               Boolean  @default(true) @map("group_messages")
  markRulesUpdates            Boolean  @default(true) @map("mark_rules_updates")
  receipts                    Boolean  @default(true)
  registrationByAdministrator Boolean  @default(true) @map("registration_by_administrator")
  registrationStart           Boolean  @default(true) @map("registration_start")
  createdAt                   DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt                   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("notification_permissions")
}

model EventHostingGroup {
  groupId String @map("group_id")
  eventId String @map("event_id")
  group   Group  @relation(fields: [groupId], references: [slug])
  event   Event  @relation(fields: [eventId], references: [id])

  @@id([groupId, eventId])
  @@map("event_hosting_group")
}

enum EmploymentType {
  PARTTIME          @map("PARTTIME")
  FULLTIME          @map("FULLTIME")
  SUMMER_INTERNSHIP @map("SUMMER_INTERNSHIP")
  OTHER             @map("OTHER")

  @@map("employment_type")
}

model JobListing {
  id               String         @id @default(uuid())
  title            String
  description      String
  shortDescription String?        @map("short_description")
  start            DateTime       @db.Timestamptz(3)
  end              DateTime       @db.Timestamptz(3)
  featured         Boolean
  hidden           Boolean
  deadline         DateTime?      @db.Timestamptz(3)
  employment       EmploymentType
  applicationLink  String?        @map("application_link")
  applicationEmail String?        @map("application_email")
  ///Applications are reviewed as soon as they are submitted
  rollingAdmission Boolean        @map("rolling_admission")
  createdAt        DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt        DateTime       @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  companyId String  @map("company_id")
  company   Company @relation(fields: [companyId], references: [id])

  locations JobListingLocation[]

  @@map("job_listing")
}

model JobListingLocation {
  name      String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  jobListingId String     @map("job_listing_id")
  jobListing   JobListing @relation(fields: [jobListingId], references: [id])

  @@id([name, jobListingId])
  @@map("job_listing_location")
}

model Offline {
  id          String   @id @default(uuid())
  title       String
  fileUrl     String?  @map("file_url")
  imageUrl    String?  @map("image_url")
  publishedAt DateTime @map("published_at") @db.Timestamptz(3)
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("offline")
}

model Article {
  id           String   @id @default(uuid())
  slug         String   @unique
  title        String
  author       String
  photographer String
  imageUrl     String   @map("image_url")
  excerpt      String
  content      String
  isFeatured   Boolean  @default(false) @map("is_featured")
  vimeoId      String?  @map("vimeo_id")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  tags ArticleTagLink[]

  @@map("article")
}

model ArticleTag {
  name String @id

  articles ArticleTagLink[]

  @@map("article_tag")
}

model ArticleTagLink {
  articleId String     @map("article_id")
  tagName   String     @map("tag_name")
  article   Article    @relation(fields: [articleId], references: [id])
  tag       ArticleTag @relation(fields: [tagName], references: [name])

  @@id([articleId, tagName])
  @@map("article_tag_link")
}

enum TaskType {
  RESERVE_ATTENDEE          @map("RESERVE_ATTENDEE")
  CHARGE_ATTENDEE           @map("CHARGE_ATTENDEE")
  MERGE_ATTENDANCE_POOLS    @map("MERGE_ATTENDANCE_POOLS")
  VERIFY_PAYMENT            @map("VERIFY_PAYMENT")
  VERIFY_FEEDBACK_ANSWERED  @map("VERIFY_FEEDBACK_ANSWERED")
  SEND_FEEDBACK_FORM_EMAILS @map("SEND_FEEDBACK_FORM_EMAILS")
  VERIFY_ATTENDEE_ATTENDED  @map("VERIFY_ATTENDEE_ATTENDED")

  @@map("task_type")
}

enum TaskStatus {
  PENDING   @map("PENDING")
  RUNNING   @map("RUNNING")
  COMPLETED @map("COMPLETED")
  FAILED    @map("FAILED")
  CANCELED  @map("CANCELED")

  @@map("task_status")
}

model Task {
  id          String     @id @default(uuid())
  type        TaskType
  status      TaskStatus @default(PENDING)
  payload     Json       @default("{}")
  createdAt   DateTime   @default(now()) @map("created_at") @db.Timestamptz(3)
  scheduledAt DateTime   @map("scheduled_at") @db.Timestamptz(3)
  processedAt DateTime?  @map("processed_at") @db.Timestamptz(3)

  recurringTaskId String?        @map("recurring_task_id")
  recurringTask   RecurringTask? @relation(fields: [recurringTaskId], references: [id], onDelete: SetNull)

  attendancePools AttendancePool[]

  @@index([scheduledAt, status], name: "idx_job_scheduled_at_status")
  @@map("task")
}

model RecurringTask {
  id        String    @id @default(uuid())
  type      TaskType
  payload   Json      @default("{}")
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  schedule  String
  lastRunAt DateTime? @map("last_run_at") @db.Timestamptz(3)
  nextRunAt DateTime  @map("next_run_at") @db.Timestamptz(3)

  tasks Task[]

  @@index([nextRunAt])
  @@map("recurring_task")
}

enum FeedbackQuestionType {
  TEXT        @map("TEXT")
  LONGTEXT    @map("LONGTEXT")
  RATING      @map("RATING")
  CHECKBOX    @map("CHECKBOX")
  SELECT      @map("SELECT")
  MULTISELECT @map("MULTISELECT")

  @@map("feedback_question_type")
}

enum DeregisterReasonType {
  SCHOOL            @map("SCHOOL")
  WORK              @map("WORK")
  ECONOMY           @map("ECONOMY")
  TIME              @map("TIME")
  SICK              @map("SICK")
  NO_FAMILIAR_FACES @map("NO_FAMILIAR_FACES")
  OTHER             @map("OTHER")

  @@map("deregister_reason_type")
}

model FeedbackForm {
  id                 String   @id @default(uuid())
  publicResultsToken String   @unique @default(uuid()) @map("public_results_token")
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt          DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)
  answerDeadline     DateTime @map("answer_deadline") @db.Timestamptz(3)

  eventId String @unique @map("event_id")
  event   Event  @relation(fields: [eventId], references: [id])

  questions FeedbackQuestion[]
  answers   FeedbackFormAnswer[]

  @@map("feedback_form")
}

model FeedbackQuestion {
  id                  String               @id @default(uuid())
  label               String
  required            Boolean              @default(false)
  showInPublicResults Boolean              @default(true) @map("show_in_public_results")
  type                FeedbackQuestionType
  order               Int
  createdAt           DateTime             @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt           DateTime             @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  feedbackFormId String       @map("feedback_form_id")
  feedbackForm   FeedbackForm @relation(fields: [feedbackFormId], references: [id], onDelete: Cascade)

  options FeedbackQuestionOption[]
  answers FeedbackQuestionAnswer[] @relation("QuestionAnswers")

  @@map("feedback_question")
}

model FeedbackQuestionOption {
  id   String @id @default(uuid())
  name String

  questionId String           @map("question_id")
  question   FeedbackQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  selectedInAnswers FeedbackQuestionAnswerOptionLink[]

  @@unique([questionId, name])
  @@map("feedback_question_option")
}

model FeedbackQuestionAnswer {
  id    String @id @default(uuid())
  value Json?

  questionId   String             @map("question_id")
  formAnswerId String             @map("form_answer_id")
  question     FeedbackQuestion   @relation("QuestionAnswers", fields: [questionId], references: [id])
  formAnswer   FeedbackFormAnswer @relation("FormAnswers", fields: [formAnswerId], references: [id], onDelete: Cascade)

  selectedOptions FeedbackQuestionAnswerOptionLink[]

  @@map("feedback_question_answer")
}

model FeedbackQuestionAnswerOptionLink {
  feedbackQuestionOptionId String                 @map("feedback_question_option_id")
  feedbackQuestionAnswerId String                 @map("feedback_question_answer_id")
  feedbackQuestionOption   FeedbackQuestionOption @relation(fields: [feedbackQuestionOptionId], references: [id])
  feedbackQuestionAnswer   FeedbackQuestionAnswer @relation(fields: [feedbackQuestionAnswerId], references: [id], onDelete: Cascade)

  @@id([feedbackQuestionOptionId, feedbackQuestionAnswerId])
  @@map("feedback_answer_option_link")
}

model FeedbackFormAnswer {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(3)

  feedbackFormId String       @map("feedback_form_id")
  attendeeId     String       @unique @map("attendee_id")
  feedbackForm   FeedbackForm @relation(fields: [feedbackFormId], references: [id])
  attendee       Attendee     @relation(fields: [attendeeId], references: [id], onDelete: Cascade)

  answers FeedbackQuestionAnswer[] @relation("FormAnswers")

  @@map("feedback_form_answer")
}

model AuditLog {
  id            String   @id @default(uuid())
  tableName     String   @map("table_name")
  rowId         String?  @map("row_id")
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  operation     String
  rowData       Json     @map("row_data")
  /// Database transaction id
  transactionId BigInt   @map("transaction_id")

  /// User relation is optional because the system can execute operations without a user to link it to. For example with
  /// recurring tasks.
  user   User?   @relation(fields: [userId], references: [id])
  userId String? @map("user_id")

  @@map("audit_log")
}

model DeregisterReason {
  id           String               @id @default(uuid())
  createdAt    DateTime             @default(now()) @map("created_at") @db.Timestamptz(3)
  registeredAt DateTime             @map("registered_at") @db.Timestamptz(3)
  type         DeregisterReasonType
  details      String?
  userGrade    Int?                 @map("user_grade")

  userId  String @map("user_id")
  eventId String @map("event_id")
  user    User   @relation(fields: [userId], references: [id])
  event   Event  @relation(fields: [eventId], references: [id])

  @@map("deregister_reason")
}
